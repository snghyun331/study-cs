## Node JS?

크롬 V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임이다.

(v8엔진이 오픈소스로 나오면서 어떤 한 개발자가 개발함)

## Node JS 의 장점

→ 비동기 이벤트 드리븐 방식이라는 최신 기술을 사용하기 때문에 성능이 굉장히 빠르고 크롬 V8엔진을 사용하기 때문에 자바스크립트임에도 불구하고 굉장히 성능이 빠르다는 게 장점

<br>
<strong>⬇️ 아래 3가지 덕분에 멀티 태스킹을 편리하게 구현할 수 있다.</strong>

## 💜 이벤트 기반
→ 이벤트가 발생할 때 미리 지정해둔 작업을 수행하는 방식

- 이벤트 리스너에 콜백 함수를 등록한다 = 특정 이벤트가 발생할 때 무엇을 할지 미리 등록한다
- 발생한 이벤트가 없거나 발생했던 이벤트를 다 처리하면, Node는 다음 이벤트가 발생할 때까지 대기한다

<div align=center>
	<p align="center">
		<img align="center" height=180 src="https://github.com/user-attachments/assets/76d50bba-d2d1-4059-8bf5-ab36b547ca06" />
	</p>
</div>

### 이벤트 루프

→ 여러 이벤트가 동시에 발생했을 때 어떤 순서로 콜백 함수를 호출할지를 이벤트 루프가 판단

1. **API 모듈(예: setTimeout)은 비동기 요청을 처리 후 Task Queue에 callback function을 넣는다**
2. **자바스크립트 엔진은 메인 스레드에 call stack이 다 비워지면 이벤트 루프를 통해 Task Queue의 콜백 함수를 가져와서 실행**

<div align=center>
	<p align="center">
		<img align="center" height=220 src="https://github.com/user-attachments/assets/ae495443-660f-4268-841a-88f14547c6db" />
	</p>
</div>

※ Job Queue에는 Promise 객체가 담겨져 있을 거임

<br>

※ About Call Function 

→ 어떤 함수가 다른 함수의 입력값으로 전달되어서, 다른 함수에 의해 나중에 호출될 때, 그 함수를 call function이라 한다.

→ callback은 비동기 처리가 완료된 후 실행될 함수를 인자로 전달하는 방식

<br>

## 💜 논블로킹 I/O ( **≈** 비동기)

> 기본적으로 자바스크립트 상에서는 동시에 실행될 수 없지만(즉 동기로만 실행되지만), I/O 작업 같은 것은 동시에 처리될 수 있다.
> 

<br>

I/O : 입력(Input)/출력(Output)

→ 파일 시스템 접근(파일 읽기 및 쓰기, 폴더 만들기 등) , 네트워크를 통한 요청 등등

<br>

논블로킹 :  이전 작업이 완료될 때까지 대기하지 않고 다음 작업을 수행한다 ( ≈ 비동기)

블로킹 : 이전 작업이 끝나야만 다음 작업을 수행한다. ( ≈ 동기)

<br>

- <strong>Node는 I/O 작업을 백그라운드로 넘겨 동시에 처리하곤 한다. 따라서 동시에 처리될 수 있는 작업들은 최대한 묶어서 백그라운드로 넘겨야 시간을 절약할 수 있다.</strong>

- <strong>논 블로킹 방식 하에서 일부 코드는 백그라운드에서 병렬로 실행된다.</strong>
    - 일부 코드: I/O 작업(파일 시스템 접근, 네트워크 요청), 압축, 암호화 등
    - 나머지 코드는 블로킹 방식으로 실행됨

<br>

## 💜 싱글 스레드

※ 스레드 : 프로세스 내에서 실행되는 흐름의 단위

프로세스는 스레드를 여러 개 생성해 여러 작업을 동시에 처리할 수 있으며, 스레드들은 부모 프로세스의 자원을 공유한다. 따라서 같은 주소의 메모리에 접근 가능하므로 데이터를 공유할 수 있다.

- Node.js는 싱글 스레드 기반으로 동작하며, 시간이 오래 걸리는 작업은 이벤트 루프에서 대기실(Callback Queue)로 보내졌다가 스택이 비워진 후 queue에서 실행된다. (비동기 실행)
- <strong>무거운 작업이 발생하면 이벤트 루프가 막혀 성능 저하가 발생할 수 있으며, 이를 방지하기 위해 일부 애플리케이션(예: 게임)은 로딩 시간을 두거나 워커 스레드 등을 활용한다.</strong>

<br>

Node.js는 요청을 처리하는 부분은 싱글 스레드로 처리한다.

I/O 와 같은 비동기작업은 libuv를 활용하여 멀티쓰레드로 처리한다.

<br>

즉, 
<br>

직접 작성한 JS코드나 연산들은 하나의 스레드 안에서 순차적으로 처리한다.

다른 비동기 함수(db통신, 시간 정지 등)를 실행하면 이들은 따로 멀티스레드로 빼서 처리한다.

<br>

(spring은 전부 독립된 thread 안에서 순차적으로 처리한다. - 멀티 스레드)

<br>
<br>

📌 알잘딱깔센 JavaScript 비동기 프로그래밍 책 중...
    
    ### 2.4.1 비동기 실행에서 브라우저의 역할
    
    자바스크립트 엔진은 싱글 스레드로 동작하지만 브라우저 엔진은 멀티 스레드로 동작한다.
    멀티 스레드로 동작하는 브라우저가 제공하는 Web API를 함께 사용하여 비동기 동작을 구현할 수 있는 것이다. 
    예를 들어 `setTimeout` 함수로 작성된 코드가 콜 스택으로 들어오면 타이머 작동과 타이머 완료 후 콜백 함수를 큐로 보내주는 역할을 브라우저 Web API가 해주는 것이다. 
    멀티 스레드로 동작하는 브라우저 엔진이 자바스크립트에서 작성된 비동기 함수의 동작을 처리해주기 때문에 비동기 동작을 구현할 수 있다. 

  <br>
  
📌 Node JS의 교과서 책 중….
    
    노드는 싱글 스레드이지만, 엄밀히 말하면 싱글 스레드로 동작하지는 않는다. 
    노드를 실행하면 먼저 프로세스가 하나 생성되고, 그 프로세스 내부적으로 스레드가 여러 개 생성되는데 그 중 우리들이 직접 제어할 수 있는 스레드는 하나뿐이다.
    스레드를 작업을 처리하는 일손으로 표현하기도 하는데, 하나의 스레드만 직접 조작할 수 있으므로 일손이 하나인 셈이다.
    요청이 많이 들어오면 한 번에 하나씩 요청을 처리한다. 따라서 논블로킹 방법으로 대기 시간을 최대한 줄인다.
    
    노드가 싱글 스레드로 동작하지 않는 2가지 경우는, 스레드 풀(Thread Pool)과 워커 스레드(Worker Threads)이다.
    - 스레드 풀 : 특정 동작을 수행할 때 스스로 멀티 스레드를 사용 (암호화, 파일 입출력, 압축 등)
    - 워커 스레드 : (노드12~14버전부터) 멀티 스레드 사용가능 → 다수의 스레드 직접 제어 가능
    

### 요약하자면…

<div align=center>
	<p align="center">
		<img align="center" height=420 src="https://github.com/user-attachments/assets/8f25ee8b-1b8f-4949-a02b-92d9d3403006" />
	</p>
</div>

- 점원 (혹은 키오스트) : 싱글 스레드
  
    - 점원은 손님들의 주문을 모두 혼자서 처리한다.
      
    - 우리들이 직접 제어/연산 할 수 있는 부분
      
- ⚡ : 주문과 동시에 음식(디저트 등)을 픽업할 수 있는 손님
  
- ⏳ : 메인 디쉬를 주문하여, 조리가 완료될 때까지 잠시 대기해야하는 손님
  
- ⏳ 손님들에게 대기표를 부여하고 다음 손님의 주문을 처리한다 ⇒ Queue로 보냄
  
- 주방에서 요리하는 요리사들 : 멀티 스레드
  
    - 요리를 먼저 완료한 요리사 순서대로 대기 중인 손님에게 음식을 제공 ⇒ Queue에서 제거
      
    - 우리들이 직접 제어/연산 할 수 없는 부분
      
    - ≈ 브라우저 엔진

<br>

## Node VS Spring

<strong>1️⃣ 작업의 지연시간이 연산코드에 의해 발생하는 경우</strong>

- Spring ⇒ 요청에 대해서 할당해줄 수 있는 Thread (pool)가 생기기 전에는 할당이 안되기 때문에, 이미 할당된 thread에서의 작업이 끝나면 다음 작업들이 할당된다.
- Node ⇒ 싱글 스레드인 이벤트 루프에서 전부 처리하므로 모든 작업을 순차적으로 이어서하는데 걸리는 시간이 발생한다.

<strong>2️⃣ 작업의 지연시간이 I/O(비동기함수)에 의해 발생하는 경우</strong>

- Spring ⇒  I/O같은 작업은 요청 처리를 위해 할당받은 스레드가 대기하게 된다. (잘은 모름)
- Node ⇒ libuv라는 멀티쓰레드 동작하는 라이브러리로 비동기 I/O를 내보내고, callback으로 신호를 받아오기 때문에, **빠르게 I/O가 종료되는 순으로** 처리가 가능

<br>

→ 언뜻보면 성능이 똑같을 순 있지만… ⬇️

**Node가 Spring보다 더 좋은 점 (I/O 처리 시)**

<div align=center>
	<p align="center">
		<img align="center" height=400 src="https://github.com/user-attachments/assets/5cd109a8-6165-43ec-8992-8edcc7249af5" />
	</p>
</div>

→ spring은 사용중인 모든 쓰레드가 I/O처리 중이라면, I/O가 끝나기 전까지 non I/O 요청이라도 처리할 수 없다.

<div align=center>
	<p align="center">
		<img align="center" height=400 src="https://github.com/user-attachments/assets/30a332e2-cf1d-4eb2-8c99-41c5221d772e" />
	</p>
</div>

→ Node는 I/O를 처리하기 위한 모든 멀티 쓰레드가 사용 중이더라도, Spring과는 달리 비동기로 동작하는 외부 스레드인 느낌이다.

독립적인 외부 I/O처리 Thread(libuv의 쓰레드)에서 다시 메인 싱글 쓰레드로 신호를 보내줄 때까지, 그 사이에 메인 쓰레드에서 non I/O에 대한 요청이 처리가 가능하다.

<br>

> 그래도 연산자체가 복잡하면 Spring에 비해서 Node.js가 느리다는 사실은 변함이 없는 것이 아니냐? 하실 수 있고, 맞습니다.
>
> 이를 극복하기 위해서는 다음과 같은 전략을 세울 수 있습니다.
> 1. 싱글 Node.js로 구성된 서버는 연산의 빈도를 줄여야합니다.
> 2. 연산의 빈도를 줄일 수 없다면, 여러가지 병렬 기술들을 활용해야 합니다. (k8s, MSA, 클러스터링 등)

<br>

## 끝으로..

- Node는 기본적으로 싱글 스레드, 논블로킹 모델을 사용한다. 따라서 노드 서버의 장단점은 싱글 스레드, 논블로킹 모델의 장단점과 크게 다르지 않다
  
- 서버에는 기본적으로 I/O 요청이 많이 발생하므로, I/O 처리를 잘하는 Node를 서버로 사용하면 좋다.
  
- Node는 Libuv 라이브러리를 사용해 I/O 작업을 논블로킹 방식으로 처리한다. 따라서 스레드 하나가 많은 수의 I/O를 혼자서도 감당할 수 있다.
  
- 하지만 Node는 CPU 부하가 큰 작업에는 적합하지 않다.
  
    - 자바스크립트 코드는 모두 스레드 하나에서 처리된다.
      
    - 코드가 CPU 연산을 많이 요구하면 스레드 하나가 혼자서 감당하기 어렵다.
      
- Node는 개수는 많지만 크기는 작은 데이터를 실시간으로 주고받는 데 적합하다. 네트워크, 데이터베이스, 디스크 작업 같은 I/O에 특화되어있기 때문이다.
  
    - 실시간 채팅 어플리케이션이나 주식차트, JSON 데이터를 제공하는 API 서버로 많이 사용한다.

<br>

- Node 12버전에서 워커 스레드 기능의 안정화로 멀티 스레드 작업을 할 수 있게 되었지만, 멀티 스레드 프로그래밍을 하는 것은 싱글 스레드에 비해 난이도가 높다.
  
- 따라서 멀티 스레드 기능이 있다고 하더라도 이미지나 비디오 처리, 대규모 데이터 처리와 같이 CPU를 많이 사용하는 작업을 위한 서버로는 권장하지 않는다.
  
- AWS 람다, 구글 클라우드 functions 같은 서비스에서 노드로 CPU를 많이 사용하는 작업을 처리하기도 한다.

<br>

- 싱글 스레드 방식으로 서버를 운영할 때는 하나뿐인 스레드가 에러로 인해 멈추지 않도록 잘 관리해야한다.

<br>
<br>
<br>

**참고**

https://velog.io/@tennfin1/NodeJS%EA%B0%80-Spring%EB%B3%B4%EB%8B%A4-%EB%B9%A0%EB%A5%B4%EB%8B%A4%EA%B3%A0-%EC%89%BD%EA%B2%8C-%EC%84%A4%EB%AA%85%ED%95%B4%EB%93%9C%EB%A6%BC

https://www.youtube.com/watch?v=v67LloZ1ieI&t=115s

https://inpa.tistory.com/entry/NODE-%F0%9F%93%9A-%EB%85%B8%EB%93%9C-%EB%93%80%ED%86%A0%EB%A6%AC%EC%96%BC

(책) 알잘딱깔센 JavaScript 비동기 프로그래밍

(책) NodeJs의 교과서
